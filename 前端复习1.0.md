# 一、[JavaScript]() 

## 1. 原始值和引用值类型及区别 

### 变量存放类型区别：



| 类型   | 包括                                        | 变量存储   |      |
| ------ | ------------------------------------------- | ---------- | ---- |
| 原始值 | Number,String,Null,Boolean,Undefined,Symbol | 存储在栈中 |      |
| 引用值 | Array,Object,Function,Date,RegExp           | 存储在堆中 |      |



### 通过实例具体了解

- 原始值的变量类型和值都存储在栈中，栈内存和栈内存之间的赋值是拷贝。两个原始值之间不影响。

```
<script type="text/javascript">
  var num = 10;
  var num1 = num; 
  num = 20;
  document.write(num1);//10
</script>
复制代码
```

num1 = num,把num空间的值复制到num1。

![img](https://user-gold-cdn.xitu.io/2019/11/22/16e9098d30227946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

原始值的特点是不可改变，一开始num = 10,当重新赋值 num = 20时，不能在原来的地址上改变值，而是重新开辟一个空间。

![img](https://user-gold-cdn.xitu.io/2019/11/22/16e909a4bced2c7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 引用值的变量类型存储在栈中，值在堆中。当arr赋值给arr1时，在栈中拷贝地址，然后根据地址指向堆中内容。

```
<script type="text/javascript">
   var arr = [1,2];
   var arr1 = arr;
   arr.push(3);
   document.write(arr);//1,2,3
   document.write(arr1);//1,2,3
</script>
复制代码
```



![img](https://user-gold-cdn.xitu.io/2019/11/22/16e9087f50c939b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 引用值重新赋值，是新开辟一个空间，指向新的地址。所以原来的arr1不会随着arr的改变而改变。此时各自指向的地址已经不一样了。

```
<script type="text/javascript">
   var arr = [1,2];
   var arr1 = arr;
   arr = [1,2,3];
   document.write(arr);//1,2,3
   document.write(arr1);//1,2
</script>
复制代码
```



![img](https://user-gold-cdn.xitu.io/2019/11/22/16e908f881db404e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)







##  2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor 

### [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#语法)

`typeof` 运算符后接操作数：

```
typeof operand
typeof(operand)
```

### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#参数)

**`operand`**



### [描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#描述)

下表总结了 `typeof` 可能的返回值。有关类型和原始值的更多信息，可查看 [JavaScript 数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures) 页面。

| 类型                                                         | 结果                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [Undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null) | `"object"` (见[下文](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#null)) |
| [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt)(ECMAScript 2020 新增) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/zh-CN/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol) (ECMAScript 2015 新增) | `"symbol"`                                                   |
| 宿主对象（由 JS 环境提供）                                   | *取决于具体实现*                                             |
| [Function](https://developer.mozilla.org/zh-CN/docs/Glossary/Function) 对象 (按照 ECMA-262 规范实现 [[Call]]) | `"function"`                                                 |
| 其他任何对象                                                 | `"object"`                                                   |

### [示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#示例)

```
// 数值
typeof 37 === 'number';
typeof 3.14 === 'number';
typeof(42) === 'number';
typeof Math.LN2 === 'number';
typeof Infinity === 'number';
typeof NaN === 'number'; // 尽管它是 "Not-A-Number" (非数值) 的缩写
typeof Number(1) === 'number'; // Number 会尝试把参数解析成数值

typeof 42n === 'bigint';


// 字符串
typeof '' === 'string';
typeof 'bla' === 'string';
typeof `template literal` === 'string';
typeof '1' === 'string'; // 注意内容为数字的字符串仍是字符串
typeof (typeof 1) === 'string'; // typeof 总是返回一个字符串
typeof String(1) === 'string'; // String 将任意值转换为字符串，比 toString 更安全


// 布尔值
typeof true === 'boolean';
typeof false === 'boolean';
typeof Boolean(1) === 'boolean'; // Boolean() 会基于参数是真值还是虚值进行转换
typeof !!(1) === 'boolean'; // 两次调用 ! (逻辑非) 操作符相当于 Boolean()


// Symbols
typeof Symbol() === 'symbol';
typeof Symbol('foo') === 'symbol';
typeof Symbol.iterator === 'symbol';


// Undefined
typeof undefined === 'undefined';
typeof declaredButUndefinedVariable === 'undefined';
typeof undeclaredVariable === 'undefined';


// 对象
typeof {a: 1} === 'object';

// 使用 Array.isArray 或者 Object.prototype.toString.call
// 区分数组和普通对象
typeof [1, 2, 4] === 'object';

typeof new Date() === 'object';
typeof /regex/ === 'object'; // 历史结果请参阅正则表达式部分


// 下面的例子令人迷惑，非常危险，没有用处。避免使用它们。
typeof new Boolean(true) === 'object';
typeof new Number(1) === 'object';
typeof new String('abc') === 'object';

// 函数
typeof function() {} === 'function';
typeof class C {} === 'function'
typeof Math.sin === 'function';


```

### [`typeof null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null)

```
// JavaScript 诞生以来便如此
typeof null === 'object';
```

在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，`typeof null` 也因此返回 `"object"`。（[参考来源](https://www.2ality.com/2013/10/typeof-null.html)）

曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但[被拒绝了](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null)。该提案会导致 `typeof null === 'null'`。

其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉

- 000：对象
- 010：浮点数
- 100：字符串
- 110：布尔
- 1：整数

but, 对于 `undefined` 和 `null` 来说，这两个值的信息存储是有点特殊的。

`null`：所有机器码均为0

### instanceof 操作符的实现原理

之前我们提到了 `instanceof` 来判断对象的具体类型，其实 `instanceof` 主要的作用就是判断一个实例是否属于某种类型

```
let person = function () {
}
let nicole = new person()
nicole instanceof person // true
复制代码
```

当然，`instanceof` 也可以判断一个实例是否是其父类型或者祖先类型的实例。

```
let person = function () {
}
let programmer = function () {
}
programmer.prototype = new person()
let nicole = new programmer()
nicole instanceof person // true
nicole instanceof programmer // true
复制代码
```

这是 `instanceof` 的用法，但是 `instanceof` 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下

```
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;	
        }
        if (leftVaule === rightProto) {
            return true;	
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
复制代码
```

其实 `instanceof` 主要的实现原理就是只要右边变量的 `prototype` 在左边变量的原型链上即可。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

看几个很有趣的例子

```
function Foo() {
}

Object instanceof Object // true
Function instanceof Function // true
Function instanceof Object // true
Foo instanceof Foo // false
Foo instanceof Object // true
Foo instanceof Function // true
复制代码
```

要想全部理解 `instanceof` 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。

关于原型继承的原理，我简单用一张图来表示



![img](https://user-gold-cdn.xitu.io/2018/5/28/163a55d5d35b866d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我们知道每个 JavaScript 对象均有一个隐式的 `__proto__` 原型属性，而显式的原型属性是 `prototype`，只有 `Object.prototype.__proto__` 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 `instanceof` 使用的例子。

- `Object instanceof Object`

  由图可知，Object 的 `prototype` 属性是 `Object.prototype`, 而由于 Object 本身是一个函数，由 Function 所创建，所以 `Object.__proto__` 的值是 `Function.prototype`，而 `Function.prototype` 的 `__proto__` 属性是 `Object.prototype`，所以我们可以判断出，`Object instanceof Object` 的结果是 true 。用代码简单的表示一下

  ```
  leftValue = Object.__proto__ = Function.prototype;
  rightValue = Object.prototype;
  // 第一次判断
  leftValue != rightValue
  leftValue = Function.prototype.__proto__ = Object.prototype
  // 第二次判断
  leftValue === rightValue
  // 返回 true
  复制代码
  ```

  `Function instanceof Function` 和 `Function instanceof Object` 的运行过程与 `Object instanceof Object` 类似，故不再详说。

  ### Object.prototype.toString()

  ## [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#语法)

  ```
  obj.toString()
  ```

  ### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#返回值)

  一个表示该对象的字符串。

  ## [描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#描述)

  每个对象都有一个 `toString()` 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，`toString()` 方法被每个 `Object` 对象继承。如果此方法在自定义对象中未被覆盖，`toString()` 返回 "[object *type*]"，其中 `type` 是对象的类型。以下代码说明了这一点：

  ```
  var o = new Object();
  o.toString(); // returns [object Object]
  ```

  当 toString 方法被调用的时候，下面的步骤会被执行：

1. 如果 this 值是 undefined，就返回 [object Undefined]
2. 如果 this 的值是 null，就返回 [object Null]
3. 让 O 成为 ToObject(this) 的结果
4. 让 class 成为 O 的内部属性 [[Class]] 的值
5. 最后返回由 "[object " 和 class 和 "]" 三个部分组成的字符串

通过规范，我们至少知道了调用 Object.prototype.toString 会返回一个由 "[object " 和 class 和 "]" 组成的字符串，而 class 是要判断的对象的内部属性。

让我们写个 demo:

```
console.log(Object.prototype.toString.call(undefined)) // [object Undefined]
console.log(Object.prototype.toString.call(null)) // [object Null]

var date = new Date();
console.log(Object.prototype.toString.call(date)) // [object Date]
```

由此我们可以看到这个 class 值就是识别对象类型的关键！

让我们看个 demo:

```
// 以下是11种：
var number = 1;          // [object Number]
var string = '123';      // [object String]
var boolean = true;      // [object Boolean]
var und = undefined;     // [object Undefined]
var nul = null;          // [object Null]
var obj = {a: 1}         // [object Object]
var array = [1, 2, 3];   // [object Array]
var date = new Date();   // [object Date]
var error = new Error(); // [object Error]
var reg = /a/g;          // [object RegExp]
var func = function a(){}; // [object Function]

function checkType() {
    for (var i = 0; i < arguments.length; i++) {
        console.log(Object.prototype.toString.call(arguments[i]))
    }
}

checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)
```

除了以上 11 种之外，还有：

```
console.log(Object.prototype.toString.call(Math)); // [object Math]
console.log(Object.prototype.toString.call(JSON)); // [object JSON]
```

除了以上 13 种之外，还有：

```
function a() {
    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]
}
a();
```

所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。



### 总结：

​		1.typeof可用于检测String Number Boolean Undifined Symbol这五种基本类型（除了object和null） 

​			缺点：null有bug，只能准确检验基本数据类型

​		2.instanceof 可用于检测引用类型的具体类型（判断对象的具体类型）

​			缺点： `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出`iframes`。

​		3.Object.prototype.toString() 可用于检测所有的数据类型

​			缺点：不能精准判断自定义对象

```
function f(name) {
    this.name=name;
}
var f1=new f(‘martin‘);
console.log(Object.prototype.toString.call(f1));//[object Object]
```

## 3. 类数组与数组的区别与转换 

## 4. 数组的常见API 

## 5. bind、call、apply的区别 

## 6. new的原理 

## 7. 如何正确判断this？ 

## 8. 闭包及其作用 

## 9. 原型和原型链 

## 10. prototype与__proto__的关系与区别 

## 11. 继承的实现方式及比较 

## 12. 深拷贝与浅拷贝 

## 13. 防抖和节流 

## 14. 作用域和作用域链、执行期上下文 

## 15. DOM常见的操作方式 

## 16. Array.sort()方法与实现机制 

## 17. Ajax的请求过程 

## 18. JS的垃圾回收机制 

## 19. JS中的String、Array和Math方法 

## 20. addEventListener和onClick()的区别 

## 21. new和Object.create的区别 

## 22. DOM的location对象 

## 23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程） 

## 24. 跨域、同源策略及跨域实现方式和原理 

## 25. 浏览器的回流（Reflow）和重绘（Repaints） 

## 26. [JavaScript]()中的arguments 

## 27. EventLoop事件循环 

## 28. 宏任务与微任务 

## 29. BOM属性对象方法 

## 30. 函数柯里化及其通用封装 

## 31.js map和reduce方法

## 32.==和===的区别

## 33.settimeout作用于倒计时为什么有误差

#  二、ES6 

1. let、const和var的概念与区别 
2. 变量提升与暂时性死区 
3. 变量的结构赋值 
4. 箭头函数及其this问题 
5. Symbol概念及其作用 
6. Set和Map数据结构 
7. Proxy 
8. Reflect对象 
9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法） 
10. Iterator和for...of（Iterator遍历器的实现） 
11. 循环语法比较及使用场景（for、forEach、for...in、for...of） 
12. Generator及其异步方面的应用 
13. async函数 
14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async） 
15. class基本语法及继承 
16. 模块加载方案比较（CommonJS和ES6的Module） 
17. ES6模块加载与CommonJS加载的原理 

#  三、HTML/CSS 

1. CSS权重及其引入方式 
2. <a></a>标签全部作用 
3. 用CSS画三角形 
4. 未知宽高元素水平垂直居中（方案及比较） 
5. 元素种类的划分 
6. 盒子模型及其理解 
7. 定位方式及其区别（文档流） 
8. margin塌陷及合并问题 
9. 浮动模型及清除浮动的方法 
10. CSS定位属性 
11. display及相关属性 
12. IFC与BFC 
13. 圣杯布局和双飞翼布局的实现 
14. Flex布局 
15. px、em、rem的区别 
16. Less预处理语言 
17. 媒体查询 
18. vh与vw 
19. H5的语义化作用及语义化标签 
20. Web Worker和Web Socket 
21. CSS3及相关动画 
22. 如何实现响应式布局 
23. SEO的概念及实现 
24. HTML5的新特性 
25. Less和Sass使用 

#  四、HTTP与计算机网络 

1. TCP/IP协议分层管理 
2. 三次握手四次挥手机制及原因 
3. HTTP方法 
4. GET和POST的区别 
5. HTTP建立持久连接的意义 
6. HTTP报文的结构 
7. HTTP状态码 
8. Web服务器及其组成 
9. HTTP报文首部 
10. HTTP通用首部字段 
11. HTTP请求首部字段、响应首部字段、实体首部字段 
12. Cookie相关首部字段 
13. HTTPS与HTTP区别及实现方式 
14. Cookie与Session 
15. 基于HTTP的功能追加协议（SPY、WebSocket、HTTP） 
16. 常见的Web攻击分类 
17. TCP与UDP区别 
18. 存储机制localStorage、sessionStorage与Cookie存储技术 
19. XSS攻击及防御 
20. CSRF攻击及防御 

#  五、[前端]()工程化 

1. [前端]()工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、[项目]()监控）
2. Webpack基本概念与配置 
3. loader与plugin原理与实现 
4. Webpack的模块热替换及实现 
5. Webpack的优化问题 
6. SPA及其优缺点 
7. SSR实现及优缺点 
8. 设计模式（工厂模式、单例模式、原型模式、***模式、适配器模式、观察者模式等...） 

#  六、Vue



#  七、NodeJS 

1. NodeJS基本概念与特点 
2. CommonJS规范、核心模块 
3. Node的异步I/O 
4. Node的内存控制 
5. Node构建网络服务（TCP、HTTP、Web Socket服务等） 
6. Node的进程 

#  八、需要会手撕的代码部分 

1. Promise（A+规范）、then、all方法 
2. Iterator遍历器实现 
3. Thunk函数实现（结合Generator实现异步） 
4. async实现原理（spawn函数） 
5. class的继承 
6. 防抖和节流 
7. Ajax原生实现 
8. 深拷贝的几种方法与比较 
9. 继承的几种实现与比较 
10. 未知宽高的元素水平垂直居中 
11. 三栏布局的实现 
12. 两栏布局的实现 
13. React高阶组件 
14. 数组去重 
15. 几种[排序]()[算法]()的实现及其复杂度比较
16. 前序后序遍历[二叉树]()（非递归）
17. [二叉树]()深度遍历（分析时间复杂度）
18. 跨域的实现（JSONP、CORS） 

#  九、数据可视化 

1. Canvas和SVG的区别 
2. 在考虑设计可视化图表时，结合Canvas和SVG特性会怎么取舍 
3. 常见的可视化组件库 
4. 可视化组件库如Echarts的设计思路 
5. 一些偏向底层的可视化组件库和[前端]()框架结合方面需要考虑哪些问题
6. 可视化组件如何做到数据驱动？ 

#  十、计算机基础 

1. 计算机系统 
2. 线程与进程 
3. 常见的git指令 
4. Linux相关指令 
5. 其他类型的编程语言（如Java） 
6. 数据库