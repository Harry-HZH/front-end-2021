# 一、[JavaScript]() 

## 1. 原始值和引用值类型及区别 

### 变量存放类型区别：



| 类型   | 包括                                        | 变量存储   |      |
| ------ | ------------------------------------------- | ---------- | ---- |
| 原始值 | Number,String,Null,Boolean,Undefined,Symbol | 存储在栈中 |      |
| 引用值 | Array,Object,Function,Date,RegExp           | 存储在堆中 |      |



### 通过实例具体了解

- 原始值的变量类型和值都存储在栈中，栈内存和栈内存之间的赋值是拷贝。两个原始值之间不影响。

```
<script type="text/javascript">
  var num = 10;
  var num1 = num; 
  num = 20;
  document.write(num1);//10
</script>
复制代码
```

num1 = num,把num空间的值复制到num1。

![img](https://user-gold-cdn.xitu.io/2019/11/22/16e9098d30227946?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

原始值的特点是不可改变，一开始num = 10,当重新赋值 num = 20时，不能在原来的地址上改变值，而是重新开辟一个空间。

![img](https://user-gold-cdn.xitu.io/2019/11/22/16e909a4bced2c7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 引用值的变量类型存储在栈中，值在堆中。当arr赋值给arr1时，在栈中拷贝地址，然后根据地址指向堆中内容。

```
<script type="text/javascript">
   var arr = [1,2];
   var arr1 = arr;
   arr.push(3);
   document.write(arr);//1,2,3
   document.write(arr1);//1,2,3
</script>
复制代码
```



![img](https://user-gold-cdn.xitu.io/2019/11/22/16e9087f50c939b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 引用值重新赋值，是新开辟一个空间，指向新的地址。所以原来的arr1不会随着arr的改变而改变。此时各自指向的地址已经不一样了。

```
<script type="text/javascript">
   var arr = [1,2];
   var arr1 = arr;
   arr = [1,2,3];
   document.write(arr);//1,2,3
   document.write(arr1);//1,2
</script>
复制代码
```



![img](https://user-gold-cdn.xitu.io/2019/11/22/16e908f881db404e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)







##  2. 判断数据类型typeof、instanceof、Object.prototype.toString.call()、constructor 

### [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#语法)

`typeof` 运算符后接操作数：

```
typeof operand
typeof(operand)
```

### [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#参数)

**`operand`**



### [描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#描述)

下表总结了 `typeof` 可能的返回值。有关类型和原始值的更多信息，可查看 [JavaScript 数据结构](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures) 页面。

| 类型                                                         | 结果                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [Undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null) | `"object"` (见[下文](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#null)) |
| [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt)(ECMAScript 2020 新增) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/zh-CN/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol) (ECMAScript 2015 新增) | `"symbol"`                                                   |
| 宿主对象（由 JS 环境提供）                                   | *取决于具体实现*                                             |
| [Function](https://developer.mozilla.org/zh-CN/docs/Glossary/Function) 对象 (按照 ECMA-262 规范实现 [[Call]]) | `"function"`                                                 |
| 其他任何对象                                                 | `"object"`                                                   |

### [示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#示例)

```
// 数值
typeof 37 === 'number';
typeof 3.14 === 'number';
typeof(42) === 'number';
typeof Math.LN2 === 'number';
typeof Infinity === 'number';
typeof NaN === 'number'; // 尽管它是 "Not-A-Number" (非数值) 的缩写
typeof Number(1) === 'number'; // Number 会尝试把参数解析成数值

typeof 42n === 'bigint';


// 字符串
typeof '' === 'string';
typeof 'bla' === 'string';
typeof `template literal` === 'string';
typeof '1' === 'string'; // 注意内容为数字的字符串仍是字符串
typeof (typeof 1) === 'string'; // typeof 总是返回一个字符串
typeof String(1) === 'string'; // String 将任意值转换为字符串，比 toString 更安全


// 布尔值
typeof true === 'boolean';
typeof false === 'boolean';
typeof Boolean(1) === 'boolean'; // Boolean() 会基于参数是真值还是虚值进行转换
typeof !!(1) === 'boolean'; // 两次调用 ! (逻辑非) 操作符相当于 Boolean()


// Symbols
typeof Symbol() === 'symbol';
typeof Symbol('foo') === 'symbol';
typeof Symbol.iterator === 'symbol';


// Undefined
typeof undefined === 'undefined';
typeof declaredButUndefinedVariable === 'undefined';
typeof undeclaredVariable === 'undefined';


// 对象
typeof {a: 1} === 'object';

// 使用 Array.isArray 或者 Object.prototype.toString.call
// 区分数组和普通对象
typeof [1, 2, 4] === 'object';

typeof new Date() === 'object';
typeof /regex/ === 'object'; // 历史结果请参阅正则表达式部分


// 下面的例子令人迷惑，非常危险，没有用处。避免使用它们。
typeof new Boolean(true) === 'object';
typeof new Number(1) === 'object';
typeof new String('abc') === 'object';

// 函数
typeof function() {} === 'function';
typeof class C {} === 'function'
typeof Math.sin === 'function';


```

### [`typeof null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null)

```
// JavaScript 诞生以来便如此
typeof null === 'object';
```

在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，`typeof null` 也因此返回 `"object"`。（[参考来源](https://www.2ality.com/2013/10/typeof-null.html)）

曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但[被拒绝了](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null)。该提案会导致 `typeof null === 'null'`。

其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉

- 000：对象
- 010：浮点数
- 100：字符串
- 110：布尔
- 1：整数

but, 对于 `undefined` 和 `null` 来说，这两个值的信息存储是有点特殊的。

`null`：所有机器码均为0

### instanceof 操作符的实现原理

之前我们提到了 `instanceof` 来判断对象的具体类型，其实 `instanceof` 主要的作用就是判断一个实例是否属于某种类型

```
let person = function () {
}
let nicole = new person()
nicole instanceof person // true
复制代码
```

当然，`instanceof` 也可以判断一个实例是否是其父类型或者祖先类型的实例。

```
let person = function () {
}
let programmer = function () {
}
programmer.prototype = new person()
let nicole = new programmer()
nicole instanceof person // true
nicole instanceof programmer // true
复制代码
```

这是 `instanceof` 的用法，但是 `instanceof` 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下

```
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;	
        }
        if (leftVaule === rightProto) {
            return true;	
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
复制代码
```

其实 `instanceof` 主要的实现原理就是只要右边变量的 `prototype` 在左边变量的原型链上即可。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

看几个很有趣的例子

```
function Foo() {
}

Object instanceof Object // true
Function instanceof Function // true
Function instanceof Object // true
Foo instanceof Foo // false
Foo instanceof Object // true
Foo instanceof Function // true
复制代码
```

要想全部理解 `instanceof` 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。

关于原型继承的原理，我简单用一张图来表示



![img](https://user-gold-cdn.xitu.io/2018/5/28/163a55d5d35b866d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我们知道每个 JavaScript 对象均有一个隐式的 `__proto__` 原型属性，而显式的原型属性是 `prototype`，只有 `Object.prototype.__proto__` 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 `instanceof` 使用的例子。

- `Object instanceof Object`

  由图可知，Object 的 `prototype` 属性是 `Object.prototype`, 而由于 Object 本身是一个函数，由 Function 所创建，所以 `Object.__proto__` 的值是 `Function.prototype`，而 `Function.prototype` 的 `__proto__` 属性是 `Object.prototype`，所以我们可以判断出，`Object instanceof Object` 的结果是 true 。用代码简单的表示一下

  ```
  leftValue = Object.__proto__ = Function.prototype;
  rightValue = Object.prototype;
  // 第一次判断
  leftValue != rightValue
  leftValue = Function.prototype.__proto__ = Object.prototype
  // 第二次判断
  leftValue === rightValue
  // 返回 true
  复制代码
  ```

  `Function instanceof Function` 和 `Function instanceof Object` 的运行过程与 `Object instanceof Object` 类似，故不再详说。

  ### Object.prototype.toString()

  ## [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#语法)

  ```
  obj.toString()
  ```

  ### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#返回值)

  一个表示该对象的字符串。

  ## [描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#描述)

  每个对象都有一个 `toString()` 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，`toString()` 方法被每个 `Object` 对象继承。如果此方法在自定义对象中未被覆盖，`toString()` 返回 "[object *type*]"，其中 `type` 是对象的类型。以下代码说明了这一点：

  ```
  var o = new Object();
  o.toString(); // returns [object Object]
  ```

  当 toString 方法被调用的时候，下面的步骤会被执行：

1. 如果 this 值是 undefined，就返回 [object Undefined]
2. 如果 this 的值是 null，就返回 [object Null]
3. 让 O 成为 ToObject(this) 的结果
4. 让 class 成为 O 的内部属性 [[Class]] 的值
5. 最后返回由 "[object " 和 class 和 "]" 三个部分组成的字符串

通过规范，我们至少知道了调用 Object.prototype.toString 会返回一个由 "[object " 和 class 和 "]" 组成的字符串，而 class 是要判断的对象的内部属性。

让我们写个 demo:

```
console.log(Object.prototype.toString.call(undefined)) // [object Undefined]
console.log(Object.prototype.toString.call(null)) // [object Null]

var date = new Date();
console.log(Object.prototype.toString.call(date)) // [object Date]
```

由此我们可以看到这个 class 值就是识别对象类型的关键！

让我们看个 demo:

```
// 以下是11种：
var number = 1;          // [object Number]
var string = '123';      // [object String]
var boolean = true;      // [object Boolean]
var und = undefined;     // [object Undefined]
var nul = null;          // [object Null]
var obj = {a: 1}         // [object Object]
var array = [1, 2, 3];   // [object Array]
var date = new Date();   // [object Date]
var error = new Error(); // [object Error]
var reg = /a/g;          // [object RegExp]
var func = function a(){}; // [object Function]

function checkType() {
    for (var i = 0; i < arguments.length; i++) {
        console.log(Object.prototype.toString.call(arguments[i]))
    }
}

checkType(number, string, boolean, und, nul, obj, array, date, error, reg, func)
```

除了以上 11 种之外，还有：

```
console.log(Object.prototype.toString.call(Math)); // [object Math]
console.log(Object.prototype.toString.call(JSON)); // [object JSON]
```

除了以上 13 种之外，还有：

```
function a() {
    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]
}
a();
```

所以我们可以识别至少 14 种类型，当然我们也可以算出来，[[class]] 属性至少有 12 个。



### 总结：

​		1.typeof可用于检测String Number Boolean Undifined Symbol这五种基本类型（除了object和null） （还有function也可以检测）

​			缺点：null有bug，只能准确检验基本数据类型

​		2.instanceof 可用于检测引用类型的具体类型（判断对象的具体类型）

​			缺点： `instanceof` 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true，且不同于其他两种方法的是它不能检测出`iframes`。

​		3.Object.prototype.toString() 可用于检测所有的数据类型

​			缺点：不能精准判断自定义对象

```
function f(name) {
    this.name=name;
}
var f1=new f(‘martin‘);
console.log(Object.prototype.toString.call(f1));//[object Object]
```

## 3. 可迭代对象、类数组、数组的区别与转换 

### 概览

- 可迭代对象是指实现了 `[Symbol.iterator]` 方法属性的对象。
- 类数组对象则具有一个 `.length` 属性。
- 可以使用 `Array.from` 将可迭代对象和类数组对象转为真实数组。



![image.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7dcf8c8d6d9dc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 辨别

[可迭代对象](https://www.yuque.com/zhangbao/weekly/day-4)与[类数组对象](https://www.yuque.com/zhangbao/weekly/day-5)是两个完全不同的概念，不要弄混了。

- *可迭代对象* 是指实现了 `[Symbol.iterator]` 方法属性的对象。
- *类数组对象* 则具有一个 `.length` 属性，因此说它是类似数组的。

比如，下面的类数组对象就能不用 `for...of` 循环遍历。

```
// 因为具有 length 属性，因此属于类数组对象
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

// 报错！for...of 是无法遍历没有部署 [Symbol.iterator] 属性的对象的
for (let item of arrayLike) {}
复制代码
```

但是，**可迭代对象和类数组对象并非是相互排斥的**。比如，字符串对象既是可迭代对象（能够被 `for...of` 循环遍历），又是类数组对象。



![image.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7dcf8c8d5f0ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



但不管是可迭代对象还是类数组对象，说其他它们都**不是真实意义上的数组**，因此不具备诸如 `forEach`、`map`、`filter`、`reduce` 等这些数组方法。这有时会给我们操作对象带来很大的不便，那么我们该如何做，才能在这些对象上使用数组方法呢？

答案是可以使用 `Array.from` 方法。

### Array.from

[`Array.from`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 这个方法神奇的地方在于，它可以将传入的可迭代对象或类数组对象，都能转换成真实的数组。



### 两个例子

举个例子：



![image.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7dcf8c9e8053d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



看到没，`arrayLike` 传入 `Array.from` 之后，返回的是真实的数组。这样我们就能很方便的使用数组方法操作数据了。

再以[《可迭代对象》](https://www.yuque.com/zhangbao/weekly/day-4)一文里的 `range` 变量为例（如下）。

```
let range = {
  from: 1,
  to: 5
}

range[Symbol.iterator] = function() {
  return {
    current: this.from,
    last: this.to,
    next() {
      if (this.current <= this.last) {
        return { done: false, value: this.current++ }
      } else {
        return { done: true }
      }
    }
  }
}
复制代码
```

我们用 `Array.from` 处理一下。



![image.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7dcf8ca685b7d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



发现也被正常处理了。



### 完整语法

其实上面都是基本用户，Array.from 方法的完整语法是这样的：

```
Array.from(obj[, mapFn, thisArg])
复制代码
```

除了之前使用过的第一个参数，即被处理的对象，另外两个可选参数含义是：

- `mapFn`：在将每个成员添加进最终返回的数组之前，执行的映射函数。
- `thisArg`：指定映射函数执行上下文 `this` 的值。

举个例子：



![image.png](https://user-gold-cdn.xitu.io/2020/1/7/16f7dcf8caaa1ca3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



从上图可以看见，通过将 `mapFn` 内的 `this` 指向 `thisArg`，我们将 `"apple"` 转为了 `"🍎"`，将 `"banana"` 转为了 `"🍌"`，最后得到了最终返回的数组 `["🍎", "🍌"]`。

## 4. 数组的常见API 

​	前言

我们在学到js中数组的时候，我们会接触到js中数组的一些方法这些方法对我们来说，可以很便利的达到我们想要的结果，但是因为方法比较多，有些方法也不常用，可能会过一段时间就会忘记，那么在这里我整理了21个数组的方法，供大家查阅。

### 常用数组方法汇总

![img](https://pic4.zhimg.com/80/v2-1011afa98a4a69b5bc58a2824d6813ef_720w.jpg)

### 方法解析

### 1：concat();

功能：`合并数组`，可以合并一个或多个数组，会返回合并数组之后的数据，`不会改变原来的数组`；

```js
var str1 = [12,2,"hello"];var str2 = ["world"];
console.log(str1.concat(str2));　　　　　　　　//[12, 2, "hello", "world"]
console.log(str1);　　　　　　　　　　　　　　　　//[12,2,"hello"];
```

### 2：join();

功能：将数组转为字符串并返回转化的字符串数据，不会改变原来的数组；

注意：()中用双引号包括自己想用的分隔符，默认为逗号，这里方便观察，我用了-　　

```js
var str1 = [12,2,"hello"];
var str2 = ["world"];
console.log(str1.join("-"));　　　　　　　　//12-2-hello
console.log(str1);　　　　　　　　　　　　　　//[12, 2, "hello"]
```

### 3：pop();

功能：`删除数组的最后一位`，并且`返回删除的数据，会改变原来的数组`

```js
var str1 = [12,2,"hello"];
console.log(str1.pop()　　　　　　　　//hello
console.log(str1);　　　　　　　　　　//[12, 2]
```

### 4：shift();

功能：`删除数组的第一位数据`，并且`返回删除的数据，会改变原来的数组`。

### 5：unshift();

功能：在数组的`首位新增一个或多数据`，并且`返回新数组的长度，会改变原来的数组`

注意：`unshift()`方法返回的数据是新数组的长度，它增加的数据可以是一个也可以是多个，可以理解为增加一连串的数据，

```js
var str1 = [12,2,"hello"];
var str2 = [43,2,"test"];
console.log(str1.unshift("你好"));　　　　　　　　　　　　　　//4
console.log(str2.unshift("hello","world"));　　　　　　　　//5
console.log(str1);　　　　　　　　　　　　　　　　　　　　　　　//["你好", 12, 2, "hello"]
console.log(str2);　　　　　　　　　　　　　　　　　　　　　　　//["hello", "world", 43, 2, "test"]
```

### 6：push();

功能：在数组的最后一位新增一个或多个数据，并且返回新数组的长度，会改变原来的数组

注意：push()方法返回的是数据是新数组的长度，它增加的数据可以是一个也可以是多个，可以理解为增加一连串的数据。

```js
var str1 = [12,2,"hello"];
var str2 = [43,2,"test"];
console.log(str1.push("你好"));　　　　　　　　　　//4
console.log(str2.push("hello","world"));　　　　//5
console.log(str1);　　　　　　　　　　　　　　　　　//[12, 2, "hello","你好"]
console.log(str2);　　　　　　　　　　　　　　　　　//[43, 2, "test","hello", "world"]
```

### 7：reverse();

功能：将`数组的数据进行反转，并且返回反转后的数组，会改变原数组`

```js
var str1 = [12,2,"hello"];
console.log(str1.reverse());　　　　　　//["hello", 2, 12]
console.log(str1);　　　　　　　　　　　　//["hello", 2, 12]
```

### 8：sort();

功能：对数组内的数据进行排序(默认为升序)，并且返回排过序的新数组，会改变原来的数组

注意：

- 8.1：这里的排序是`针对字符的排序`，先使用数组的`toString()`方法转为字符串，再逐位比较，3是大于12的，因为首位`3>1`，不要与`Number`型的数据排序混淆
- 8.2：`str2`数组中增加了三个字符，可以看到，比较的时候，`zoom`是最大的，因为首位的英文字母通过`ASCII`码可以转为相应的数值，再根据数值比较

```js
var str1 = [12,2,43,5,2,5];
var str2 = [92,2,43,"hello",'zoom',5,2,5];
console.log(str1.sort());//[12, 2, 2, 43, 5, 5]
console.log(str1);//[12, 2, 2, 43, 5, 5]
console.log(str2.sort());//[2, 2, 43, 5, 5, 92, "abc", "hello", "zoom"]
console.log(str2);//[2, 2, 43, 5, 5, 92, "abc", "hello", "zoom"]
```

- 8.3：排序问题

参数：`sort(callback)` 如果需要按照数值排序，需要传参。`sort(callback)`，`callback`为回调函数，该函数应该具有两个参数，比较这两个参数，然后返回一个用于说明这两个值的相对顺序的数字`（a-b）`。其返回值如下：

若 a 小于 b，返回一个小于 0 的值。

若 a 等于 b，则返回 0。

若 a 大于 b，则返回一个大于 0 的值。

```js
var str3 = [92,2,43,5,2,5];     
console.log(str3.sort(fn));　　　　　　　　　　　　　　　　　//[2, 2, 5, 5, 43, 92]
console.log(str3);　　　　　　　　　　　　　　　　　　　　　　//[2, 2, 5, 5, 43, 92]
function fn (a,b){
　　　　return a-b;
 }
```

### 9：slice();

功能：截取指定位置的数组，并且返回截取的数组，不会改变原数组

参数：`slice(startIndex, endIndex)`

注意：可从已有的数组中返回选定的元素。该方法接收两个参数`slice(start,end)`，`stsrt`为必选，表示从第几位开始；`end`为可选，表示到第几位结束(不包含end位)，省略表示到最后一位；start和end都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。

```js
var arr = ["T1","J1","L1","L2","M1"];
    console.log(arr.slice(1,3));        //["J1","L1"]
    console.log(arr.slice(1));          //["J1","L1","L2","M1"]
    console.log(arr.slice(-4,-1));      //["J1","L1","L2"]
    console.log(arr.slice(-2));         //["Lily","M1"]
    console.log(arr.slice(1,-2));       //["J1","L1"]
    console.log(arr);                   //["T1","J1","L1","L2","M1"]
```

### 10：splice();

功能：向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。（增删改）

参数：`splice(start,num,data1,data2,...)`; 所有参数全部可选。

start：删除数组元素的开始索引

num（可选）：需要删除的元素个数

data1、data2...（可选）：插入数组的元素

##### 1.如何增加元素

```js
var arr = ["Tom","Jack","Lucy","Lily","May"];
console.log(arr.splice(2,0,"a","b"));//[]
console.log(arr);//["Tom", "Jack", "a", "b", "Lucy", "Lily", "May"]---原数组改变
```

##### 2.如何删除数组元素

```js
const numbers = [1, 2, 3, 4, 5];
const removes = numbers.splice(2);
console.log(numbers); //[1, 2]
console.log(removes); //[3, 4, 5]
```

##### 3.如何替换元素

```
//替换第2，3位的元素
const numbers = [1, 2, 3, 4, 5];
const removes = numbers.splice(2, 2, 'A', 'B');
console.log(numbers); //[1, 2, "A", "B", 5]

console.log(removes); //[3, 4]
```

### 11：toString();

功能：将数组转换成字符串，`类似于没有参数的join()`。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。不会改变原数组

```js
var str = [1,2,3];
console.log(str.toString()); //1,2,3
console.log(str);//[1,2,3]
```

### 12：valueOf();

功能：返回数组的原始值（一般情况下其实就是数组自身），一般由js在后台调用，并不显式的出现在代码中

```js
var str = [1,2,3];
console.log(str.valueOf()); //[1,2,3]
console.log(str); //[1,2,3]
//为了证明返回的是数组自身
console.log(str.valueOf() == str);//true
```

### 13：IndexOf();（查）

功能：根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引

参数：indexOf(value, start);value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1

```
注意：如果找到该数据，立即返回该数据的索引，不再往后继续查找
var str = ["h","e","l","l","o"];
 console.log(str.indexOf("l"));        //2
 console.log(str.indexOf("l",3));      //3
 console.log(str.indexOf("l",4));      //-1
 console.log(str.indexOf("l",-1));     //-1
 console.log(str.indexOf("l",-3));     //2
```

### 14：lastIndexOf();（查）

功能：lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则`在一个字符串中的指定位置从后向前搜索`。

参数：lastIndexOf(value, start);value为要查询的数据；start为可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。

```js
var str = ["h","e","l","l","o"];
console.log(str.lastIndexOf("l"));        //3
console.log(str.lastIndexOf("l",3));      //3
console.log(str.lastIndexOf("l",4));      //3
console.log(str.lastIndexOf("l",-1));     //3
console.log(str.lastIndexOf("l",-3));     //2
```

- 注意： 该方法将`从后向前`检索字符串，但返回是从起始位置 (0) 开始计算子字符串最后出现的位置。 看它是否含有字符串。 开始检索的位置在字符串的 start 处或字符串的结尾（没有指定 start 时）。 `如果没有找到匹配字符串则返回 -1 。`
- 注意：lastIndexOf() 方法是区分大小写的！

### 15：includes()；查

检测数组 *site* 是否包含 runoob :

```js
[1, 2, 3].includes(2);   ``// true
[1, 2, 3].includes(4);   ``// false
[1, 2, 3].includes(3, 3); ``// false
[1, 2, 3].includes(3, -1); ``// true
[1, 2, NaN].includes(NaN); ``// true
```



### 16：forEach();

功能：ES5新增的方法，用来遍历数组，没有返回值，

参数：forEach(callback);callback默认有三个参数，分别为value(遍历到的数组的数据)，index(对应的索引)，self(数组自身)。

```js
var arr = ["Tom","Jack","Lucy","Lily","May"];
var a = arr.forEach(function(value,index,self){
     console.log(value + "--" + index + "--" + (arr === self));
})
// 打印结果为：
// Tom--0--true
// Jack--1--true
// Lucy--2--true
// Lily--3--true
// May--4--true
console.log(a);     //undefined---forEach没有返回值
//该方法为遍历方法，不会修改原数组
```

### 17：map();

功能：

同forEach功能；

map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。

- 参数：`map(callback)`;callback默认有三个参数，分别为`value，index，self`。跟上面的forEach()的参数一样

```js
//功能1：同forEach
    var arr = ["Tom","Jack","Lucy","Lily","May"];
    var a = arr.map(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr === self))
    })
    // 打印结果为：
    // Tom--0--true
    // Jack--1--true
    // Lucy--2--true
    // Lily--3--true
    // May--4--true

    //功能2：每次回调函数的返回值被map组成新数组返回
    var arr = ["Tom","Jack","Lucy","Lily","May"];
    var a = arr.map(function(value,index,self){
        return "hi:"+value;
    })
    console.log(a);     //["hi:Tom", "hi:Jack", "hi:Lucy", "hi:Lily", "hi:May"]
    console.log(arr);   //["Tom", "Jack", "Lucy", "Lily", "May"]---原数组未改变
```

### 18：filter();

功能： 1.同forEach功能； 2.`filter的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）`。

参数：filter(callback);callback默认有三个参数，分别为value，index，self。

```js
//功能1：同forEach
    var arr = ["Tom","Jack","Lucy","Lily","May"];
    var a = arr.filter(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr === self))
    })
    // 打印结果为：
    // Tom--0--true
    // Jack--1--true
    // Lucy--2--true
    // Lily--3--true
    // May--4--true

    //功能2：当回调函数的返回值为true时，本次的数组值返回给filter，被filter组成新数组返回
    var arr = ["Tom","Jack","Lucy","Lily","May"];
    var a = arr.filter(function(value,index,self){
        return value.length > 3;
    })
    console.log(a);         //["Jack", "Lucy", "Lily"]
    console.log(arr);       //["Tom", "Jack", "Lucy", "Lily", "May"]---原数组未改变
```

### 19：every();

功能：`判断数组中每一项是否都满足条件，只有所有项都满足条件，才会返回true`。

参数：every()接收一个回调函数作为参数，这个回调函数需要有返回值，every(callback);callback默认有三个参数，分别为value，index，self。

功能1：当回调函数的返回值为true时，类似于forEach的功能，遍历所有；如果为false，那么停止执行，后面的数据不再遍历，`停在第一个返回false的位置`。

```js
//demo1:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.every(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr == self))
    })
    // 打印结果为：
    // Tom--0--true
    //因为回调函数中没有return true，默认返回undefined，等同于返回false

    //demo2:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.every(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr == self))
        return value.length < 4;
    })
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true
    //因为当遍历到Jack时，回调函数到return返回false，此时Jack已经遍历，但是后面数据就不再被遍历了

    //demo3:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.every(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr == self))
        return true;
    })
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true
    // Lucy--3--true
    // Lily--4--true
    // May--5--true
    //因为每个回调函数的返回值都是true，那么会遍历数组所有数据，等同于forEach功能
```

功能2：当每个回调函数的返回值都为true时，every的返回值为true，只要有一个回调函数的返回值为false，every的返回值都为false

### 20：some();

功能：`判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true`。

参数：some()接收一个回调函数作为参数，这个回调函数需要有返回值，some(callback);callback默认有三个参数，分别为value，index，self。

功能1：因为要判断数组中的每一项，只要有一个回调函数返回true，some都会返回true，所以与every正好相反，当遇到一个回调函数的返回值为true时，可以确定结果，那么停止执行，后面都数据不再遍历，停在第一个返回true的位置；当回调函数的返回值为false时，需要继续向后执行，到最后才能确定结果，所以会遍历所有数据，实现类似于forEach的功能，遍历所有。

```js
//demo1:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.some(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr == self))
        return value.length > 3;
    })
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true

    //demo2:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.some(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr == self))
        return true;
    })
    // 打印结果为：
    // Tom--0--true

    //demo3:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.some(function(value,index,self){
        console.log(value + "--" + index + "--" + (arr == self))
        return false;
    })
    // 打印结果为：
    // Tom--0--true
    // abc--1--true
    // Jack--2--true
    // Lucy--3--true
    // Lily--4--true
    // May--5--true
```

功能2：与every相反，只要有一个回调函数的返回值都为true，some的返回值为true，所有回调函数的返回值为false，some的返回值才为false

```js
//demo1:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.some(function(value,index,self){
        return value.length > 3;
    })
    console.log(a);             //true

    //demo2:
    var arr = ["Tom","abc","Jack","Lucy","Lily","May"];
    var a = arr.some(function(value,index,self){
        return value.length > 4;
    })
    console.log(a);             //false
```

### 21.reduce();

功能：从数组的第一项开始，逐个遍历到最后，迭代数组的所有项，然后`构建一个最终返回的值`。

参数：reduce()接收一个或两个参数：第一个是回调函数，表示在数组的每一项上调用的函数；第二个参数（可选的）作为归并的初始值，被回调函数第一次执行时的第一个参数接收。 reduce(callback,initial);callback默认有四个参数，分别为prev，now，index，self。 callback返回的任何值都会作为下一次执行的第一个参数。 如果initial参数被省略，那么第一次迭代发生在数组的第二项上，因此callback的第一个参数是数组的第一项，第二个参数就是数组的第二项。

```js
//demo1:不省略initial参数，回调函数没有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self){
        console.log(prev + "--" + now + "--" + index + "--" + (arr == self))
    }, 2019)
    // 打印结果为：
    // 2019--10--0--true
    // undefined--20--1--true
    // undefined--30--2--true
    // undefined--40--3--true
    // undefined--50--4--true
    // 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined

    //demo2:省略initial参数，回调函数没有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self){
        console.log(prev + "--" + now + "--" + index + "--" + (arr == self))
    })
    // 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项
    // 10--20--1--true
    // undefined--30--2--true
    // undefined--40--3--true
    // undefined--50--4--true
    // 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined

    //demo3:不省略initial参数，回调函数有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self){
        console.log(prev + "--" + now + "--" + index + "--" + (arr == self));
        return "hello";
    }, 2019)
    // 打印结果为：
    // 2019--10--0--true
    // hello--20--1--true
    // hello--30--2--true
    // hello--40--3--true
    // hello--50--4--true
    // 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值

    //demo4:省略initial参数，回调函数有返回值
    var arr = [10,20,30,40,50];
    arr.reduce(function(prev,now,index,self){
        console.log(prev + "--" + now + "--" + index + "--" + (arr == self));
        return "hello";
    })
    // 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项
    // 10--20--1--true
    // hello--30--2--true
    // hello--40--3--true
    // hello--50--4--true
    // 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值

    //demo5：使用reduce计算数组中所有数据的和
    var arr = [10,20,30,40,50];
    var sum = arr.reduce(function(prev,now,index,self){
        return prev + now;
    })
    console.log(sum);      //150
    // 回调函数的最后一次return的结果被返回到reduce方法的身上

    //demo6：使用reduce计算数组中所有数据的和
    var arr = [10,20,30,40,50];
    var sum = arr.reduce(function(prev,now,index,self){
        return prev + now;
    }, 8)
    console.log(sum);      //158
    // 回调函数的最后一次return的结果被返回到reduce方法的身上
    // 因为reduce有第二个参数initial，在第一次执行时被计算，所以最终结果被加上8
```

### 22.reduceRight()

功能：（与reduce类似）从数组的`最后一项`开始，向前逐个遍历到第一位，迭代数组的所有项，然后构建一个最终返回的值。

参数：同reduce。 demo：同reduce

### 三：哪些数组方法会改变原数组

unshift();

push()；

shift();

pop();

sort();

reverse();

splice();

这七个数组方法在上面都有过介绍了，可以看出，再用这些方法的时候，原数组是会被改变的。

## 5. bind、call、apply的区别 

### call 和 apply 的共同点

它们的共同点是，都能够**改变函数执行时的上下文**，将一个对象的方法交给另一个对象来执行，并且是立即执行的。

为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。

改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。

另外，它们的写法也很类似，**调用 call 和 apply 的对象，必须是一个函数 Function**。接下来，就会说到具体的写法，那也是它们区别的主要体现。

### call 和 apply 的区别

它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。

#### call 的写法

```
Function.call(obj,[param1[,param2[,…[,paramN]]]])
```

需要注意以下几点：

- 调用 call 的对象，必须是个函数 Function。
- call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。
- 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

```
function func (a,b,c) {}

func.call(obj, 1,2,3)
// func 接收到的参数实际上是 1,2,3

func.call(obj, [1,2,3])
// func 接收到的参数实际上是 [1,2,3],undefined,undefined
```

#### apply 的写法

```
Function.apply(obj[,argArray])
```

需要注意的是：

- 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。
- 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。

```
func.apply(obj, [1,2,3])
// func 接收到的参数实际上是 1,2,3

func.apply(obj, {
    0: 1,
    1: 2,
    2: 3,
    length: 3
})
// func 接收到的参数实际上是 1,2,3
```

#### 什么是类数组？

先说数组，这我们都熟悉。它的特征有：可以通过角标调用，如 array[0]；具有长度属性length；可以通过 for 循环或forEach方法，进行遍历。

那么，类数组是什么呢？顾名思义，就是**具备与数组特征类似的对象**。比如，下面的这个对象，就是一个类数组。

```
let arrayLike = {
    0: 1,
    1: 2,
    2: 3,
    length: 3
};
```

类数组 arrayLike 可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。

类数组，还是比较常用的，只是我们平时可能没注意到。比如，我们获取 DOM 节点的方法，返回的就是一个类数组。再比如，在一个方法中使用 arguments 获取到的所有参数，也是一个类数组。

但是需要注意的是：**类数组无法使用 forEach、splice、push 等数组原型链上的方法**，毕竟它不是真正的数组。

### call 和 apply 的用途

下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。

#### call 的使用场景

**1、对象的继承**。如下面这个例子：

```
function superClass () {
    this.a = 1;
    this.print = function () {
        console.log(this.a);
    }
}

function subClass () {
    superClass.call(this);
    this.print();
}

subClass();
// 1
```

subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。

**2、借用方法**。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样：

```
let domNodes = Array.prototype.slice.call(document.getElementsByTagName("*"));
```

这样，domNodes 就可以应用 Array 下的所有方法了。

#### apply 的一些妙用

**1、Math.max**。用它来获取数组中最大的一项。

```
let max = Math.max.apply(null, array);
```

同理，要获取数组中最小的一项，可以这样：

```
let min = Math.min.apply(null, array);
```

**2、实现两个数组合并**。在 ES6 的扩展运算符出现之前，我们可以用 Array.prototype.push来实现。

```
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5, 6]
```

### bind 的使用

最后来说说 bind。在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。

它的语法如下：

```
Function.bind(thisArg[, arg1[, arg2[, ...]]])
```

bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行**。而 apply 和 call 则是立即调用。

来看下面这个例子：

```
function add (a, b) {
    return a + b;
}

function sub (a, b) {
    return a - b;
}

add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
```

如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。

#### 完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是

> 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：

```
var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = 'kevin';

var bindFoo = bar.bind(foo, 'daisy');

var obj = new bindFoo('18');
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
```

注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。

### 总结

call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。

bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。



### 手写call

```js
Function.prototype.myCall = function(target, ...args) {
  // this 指向调用 myCall函数的对象
  if (typeof this !== "function") {
    throw new TypeError("not a function")
  }
  target = target || window
  target.fn = this // 隐式绑定，改变构造函数的调用者间接改变 this 指向
  let result = target.fn(...args)
  return result
};
// 测试
let obj = { name: 123 }
function foo(...args) {
  console.log(this.name, args)
}
let s = foo.myCall(obj, '111', '222')
```



#### 手写apply

```js
Function.prototype.myApply = function(target) {
  if (typeof this !== "function") {
    throw new TypeError("not a function");
  }
  if (!Array.isArray(arguments[1])) {
    throw new Error('arg not a array')
  }
  target = target || window
  target.fn = this
  let args = arguments[1]
  let result = target.fn(args)
  return result
};

const obj = { name: 123 };
function foo(...args) {
  console.log(this.name, args);
}
foo.prototype.name = 123;
const s1 = [1, 2, 3, 4, 5];
const s = foo.myApply(obj,s1);

```




### 手写bind

```js
Function.prototype.myBind = function(target){
    let self = this 

    let args = Array.prototype.slice.call(arguments,1)

    let fNOP = function(){}

    const fBound = function() {
        let bindArgs = Array.prototype.slice.call(arguments)
        return self.apply(this instanceof fNOP ? this:target,args.concat(bindArgs))
    }
    fNOP.prototype = self.prototype
    fBound.prototype = new fNOP()
    return fBound

}

var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = 'kevin';

var bindFoo = bar.myBind(foo, 'daisy');

var obj = new bindFoo('18');
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin

```



## 6. new的原理 

#### 1.new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一



1. 以构造函数的原型创造一个对象
2. 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
3. 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性
4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性
5. 返回 obj

#### 手写new

 

```
function objectFactory() {

    var obj = new Object(),

    Constructor = [].shift.call(arguments);

    obj.__proto__ = Constructor.prototype;

    var ret = Constructor.apply(obj, arguments);

    return typeof ret === 'object' ? ret : obj;

};



es6写法

function myNew(fn){
	const obj = Object.create(fn.prototype)
	
	args = [].slice.call(arguments,1)
	
	const ret = fn.apply(obj,args)
	
	const isObject = typeof res === 'object' && res !== null;
    const isFunction = typeof res === 'function';

    return isObject || isFunction ? res : obj;
}
```



## 7. 如何正确判断this？ 

### 彻底搞懂 JS 中 this 机制

> 摘要：本文属于原创，欢迎转载，转载请保留出处：https://github.com/jasonGeng88/blog

### 目录

- this 是什么
- this 的四种绑定规则
- 绑定规则的优先级
- 绑定例外
- 扩展：箭头函数

### this 是什么

理解this之前， 先纠正一个观点，**this 既不指向函数自身，也不指函数的词法作用域**。如果仅通过this的英文解释，太容易产生误导了。它实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。

### this 的四种绑定规则

this的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。

### 默认绑定

什么叫默认绑定，即没有其他绑定规则存在时的默认规则。这也是函数调用中最常用的规则。

来看这段代码：

```
function foo() { 
}       console.log( this.a );

var a = 2; 
foo(); //打印的是什么？
```

`foo()` 打印的结果是2。

因为foo()是直接调用的（独立函数调用），没有应用其他的绑定规则，这里进行了默认绑定，将全局对象绑定this上，所以this.a 就解析成了全局变量中的a，即2。

***注意：在严格模式下（strict mode），全局对象将无法使用默认绑定，即执行会报undefined的错误\***

```
function foo() { 
    "use strict";
   console.log( this.a );
}

var a = 2; 
foo(); // Uncaught TypeError: Cannot read property 'a' of undefined
```

------

### 隐式绑定

除了直接对函数进行调用外，有些情况是，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。

```
function foo() { 
    console.log( this.a );
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

obj.foo(); // ?
```

`obj.foo()` 打印的结果是3。

这里foo函数被当做引用属性，被添加到obj对象上。这里的调用过程是这样的：

获取obj.foo属性 -> 根据引用关系找到foo函数，执行调用

所以这里对foo的调用存在上下文对象obj，this进行了隐式绑定，即this绑定到了obj上，所以this.a被解析成了obj.a，即3。

#### 多层调用链

```
function foo() { 
    console.log( this.a );
}

var a = 2;

var obj1 = { 
    a: 4,
    foo: foo 
};

var obj2 = { 
    a: 3,
    obj1: obj1
};

obj2.obj1.foo(); //?
```

`obj2.obj1.foo()` 打印的结果是4。

同样，我们看下函数的调用过程：

先获取obj2.obj1 -> 通过引用获取到obj1对象，再访问 obj1.foo -> 最后执行foo函数调用

这里调用链不只一层，存在obj1、obj2两个对象，那么隐式绑定具体会绑哪个对象。这里原则是获取最后一层调用的上下文对象，即obj1，所以结果显然是4（obj1.a）。

#### 隐式丢失（函数别名）

***注意：这里存在一个陷阱，大家在分析调用过程时，要特别小心\***

先看个代码：

```
function foo() { 
    console.log( this.a );
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

var bar = obj.foo;
bar(); //?
```

<font color="red">**`bar()` 打印的结果是2。**</font>

为什么会这样，obj.foo 赋值给bar，那调用`bar()`为什么没有触发隐式绑定，使用的是默认绑定呢。

这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。

那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定，全局属性a。

#### 隐式丢失（回调函数）

```
function foo() { 
    console.log( this.a );
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

setTimeout( obj.foo, 100 ); // ？
```

<font color="red">**打印的结果是2。**</font>

同样的道理，虽然参传是`obj.foo`，因为是引用关系，所以传参实际上传的就是foo对象本身的引用。对于`setTimeout`的调用，还是 setTimeout -> 获取参数中foo的引用参数 -> 执行 foo 函数，中间没有obj的参与。这里依旧进行的是默认绑定。

------

### 显示绑定

相对隐式绑定，this值在调用过程中会动态变化，可是我们就想绑定指定的对象，这时就用到了显示绑定。

显示绑定主要是通过改变对象的prototype关联对象，这里不展开讲。具体使用上，可以通过这两个方法call(...)或apply(...)来实现（大多数函数及自己创建的函数默认都提供这两个方法）。

***call与apply是同样的作用，区别只是其他参数的设置上\***

```
function foo() { 
    console.log( this.a );
}

var a = 2;

var obj1 = { 
    a: 3,
};

var obj2 = { 
    a: 4,
};
foo.call( obj1 ); // ?
foo.call( obj2 ); // ?
```

打印的结果是3, 4。

这里因为显示的申明了要绑定的对象，所以this就被绑定到了obj上，打印的结果自然就是obj1.a 和obj2.a。

#### 硬绑定

```
function foo() { 
    console.log( this.a );
}

var a = 2;

var obj1 = { 
    a: 3,
};

var obj2 = { 
    a: 4,
};

var bar = function(){
    foo.call( obj1 );
}

bar(); // 3
setTimeout( bar, 100 ); // 3

bar.call( obj2 ); // 这是多少
```

***前面两个（函数别名、回调函数）打印3，因为显示绑定了，没什么问题。\***

最后一个打印是3。

这里需要注意下，虽然bar被显示绑定到obj2上，对于bar，function(){...} 中的this确实被绑定到了obj2，而foo因为通过`foo.call( obj1 )`已经显示绑定了obj1，所以在foo函数内，this指向的是obj1，不会因为bar函数内指向obj2而改变自身。所以打印的是obj1.a（即3）。

------

### new 绑定

***js中的new操作符，和其他语言中（如JAVA）的new机制是不一样的。js中，它就是一个普通函数调用，只是被new修饰了而已。\***

使用new来调用函数，会自动执行如下操作：

1. 如果函数没有返回其他对象,那么new表达式中的函数调用会自动返回这个新对象。

从第三点可以看出，this指向的就是对象本身。

看个代码：

```
function foo(a) { 
    this.a = a;
}

var a = 2;

var bar1 = new foo(3);
console.log(bar1.a); // ?

var bar2 = new foo(4);
console.log(bar2.a); // ?
```

最后一个打印是3, 4。

因为每次调用生成的是全新的对象，该对象又会自动绑定到this上，所以答案显而易见。

### 绑定规则优先级

上面也说过，这里在重复一下。优先级是这样的，以按照下面的顺序来进行判断:

```
 数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。
 数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话,this绑定的是 指定的对象。
 数是否在某个上下文对象中调用(隐式绑定)?如果是的话,this绑定的是那个上下文对象。
 果都不是的话,使用默认绑定。如果在严格模式下,就绑定到undefined,否则绑定到 全局对象。
 var bar = foo()
```

### 规则例外

在显示绑定中，对于null和undefined的绑定将不会生效。

代码如下：

```
function foo() { 
    console.log( this.a );
}
foo.call( null ); // 2
foo.call( undefined ); // 2
```

这种情况主要是用在不关心this的具体绑定对象（用来忽略this），而传入null实际上会进行默认绑定，导致函数中可能会使用到全局变量，与预期不符。

所以对于要忽略this的情况，可以传入一个空对象ø，该对象通过`Object.create(null)`创建。这里不用{}的原因是，ø是真正意义上的空对象，它不创建Object.prototype委托，{}和普通对象一样，有原型链委托关系。

***1. 这里传null的一种具体使用场景是函数柯里化的使用\***

### 扩展：箭头函数

最后，介绍一下ES6中的箭头函数。通过“=>”而不是function创建的函数，叫做箭头函数。它的this绑定取决于外层（函数或全局）作用域。

### case 1 (正常调用)

- 普通函数

```
function foo(){     
    console.log( this.a );
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

obj.foo(); //3
```

- 箭头函数

```
var foo = () => {     
    console.log( this.a );
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

obj.foo(); //2
foo.call(obj); //2 ，箭头函数中显示绑定不会生效
```

### case 2 （函数回调）

- 普通函数

```
function foo(){ 
    return function(){
        console.log( this.a );
    }    
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

var bar = obj.foo();
bar(); //2
```

- 箭头函数

```
function foo(){ 
    return () => {
        console.log( this.a );
    }    
}



var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

var bar = obj.foo();
bar(); //3
```

通过上面两个列子，我们看到箭头函数的this绑定<font color="red">**只取决于外层（函数或全局）的作用域**</font>，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。

***注意：对于ES6之前，箭头函数的替换版本是这样的\***

```
// es6
function foo(){ 
    return () => {
        console.log( this.a );
    }   
}

var a = 2;

var obj = { 
    a: 3,
    foo: foo 
};

var bar = obj.foo();
bar(); //3
```

通过上面两个列子，我们看到箭头函数的this绑定<font color="red">**只取决于外层（函数或全局）的作用域**</font>，对于前面的4种绑定规则是不会生效的。它也是作为this机制的一种替换，解决之前this绑定过程各种规则带来的复杂性。

***注意：对于ES6之前，箭头函数的替换版本是这样的\***

```
// es6
function foo(){ 
    return () => {
        console.log( this.a );
    }   
}

// es6之前的替代方法
function foo(){ 
     var self = this;
    return () => {
        console.log( self.a );
    }   
}
```

### 总结

我们在使用js的过程中，对于this的理解往往觉得比较困难，再调试过程中有时也会出现一些不符合预期的现象。很多时候，我们都是通过一些变通的方式（如：使用具体对象替换this）来规避的问题。可问题一直存在那儿，我们没有真正的去理解和解决它。

本文主要参考了《你不知道的JavaScript（上卷）》，对this到底是什么，具体怎么绑定的，有什么例外情况以及ES6中的一个优化方向，来彻底搞清楚我们一直使用的this到底是怎么玩的。



## 8. 闭包及其作用 

闭包属于一种特殊的作用域，称为 **静态作用域**。它的定义可以理解为: **父函数被销毁** 的情况下，返回出的子函数的`[[scope]]`中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。

- 闭包会产生一个很经典的问题:
  - 多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。
- 解决:
  - 变量可以通过 **函数参数的形式** 传入，避免使用默认的`[[scope]]`向上查找
  - 使用`setTimeout`包裹，通过第三个参数传入
  - 使用 **块级作用域**，让变量成为自己上下文的属性，避免共享





### 面试 | JS 闭包经典使用场景和含闭包必刷题

> **大家好，我是林一一，下面这篇文章是有关 JS 闭包概念和经典使用场景和必刷题的文章，让我们开始阅读吧😁**

### 思维导图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f116c4a9b8e64bbc9706249813a9b743~tplv-k3u1fbpfcp-watermark.image)

### 闭包

> 了解闭包前先来了解一下上级作用域和堆栈内存释放问题。

### 上级作用域的概念

- 函数的上级作用域在哪里创建创建的，上级作用域就是谁

```js
var a = 10
function foo(){
    console.log(a)
}

function sum() {
    var a = 20
    foo()
}

sum()
/* 输出
    10
/
复制代码
```

> **函数 `foo()` 是在全局下创建的，所以 `a` 的上级作用域就是 `window`，输出就是 `10`**

#### 思考题

```js
var n = 10
function fn(){
    var n =20
    function f() {
       n++;
       console.log(n)
     }
    f()
    return f
}

var x = fn()
x()
x()
console.log(n)
/* 输出
*  21
    22
    23
    10
/
复制代码
```

> **思路：`fn` 的返回值是什么变量 `x` 就是什么，这里 `fn` 的返回值是函数名 `f` 也就是 `f` 的堆内存地址，`x()` 也就是执行的是函数 `f()`，而不是 `fn()`，输出的结果显而易见**

- 关于如何查找上级作用域

> 参考：[彻底解决 JS 变量提升的面试题](https://juejin.cn/post/6933377315573497864)

### JS 堆栈内存释放

- 堆内存：存储引用类型值，对象类型就是键值对，函数就是代码字符串。
- 堆内存释放：将引用类型的空间地址变量赋值成 `null`，或没有变量占用堆内存了浏览器就会释放掉这个地址
- 栈内存：提供代码执行的环境和存储基本类型值。
- 栈内存释放：一般当函数执行完后函数的私有作用域就会被释放掉。

> **但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放**

### 闭包是什么

> 在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。

> 概述上面的话，**闭包是指有权访问另一个函数作用域中变量的函数**

### 形成闭包的原因

> **内部的函数存在外部作用域的引用就会导致闭包**。从上面介绍的上级作用域的概念中其实就有闭包的例子 `return f`就是一个表现形式。

```js
var a = 0
function foo(){
    var b =14
    function fo(){
        console.log(a, b)
    }
    fo()
}
foo()
复制代码
```

> 这里的子函数 `fo` 内存就存在外部作用域的引用 `a, b`，所以这就会产生闭包

### 闭包的作用

- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

### 闭包经典使用场景

- 1. `return` 回一个函数

```js
var n = 10
function fn(){
    var n =20
    function f() {
       n++;
       console.log(n)
     }
    return f
}

var x = fn()
x() // 21
复制代码
```

> 这里的 return `f`, `f()`就是一个闭包，存在上级作用域的引用。

- 1. 函数作为参数

```js
var a = '林一一'
function foo(){
    var a = 'foo'
    function fo(){
        console.log(a)
    }
    return fo
}

function f(p){
    var a = 'f'
    p()
}
f(foo())
/* 输出
*   foo
/ 
复制代码
```

> 使用 return `fo` 返回回来，`fo()` 就是闭包，`f(foo())` 执行的参数就是函数 `fo`，因为 `fo() 中的 a` 的上级作用域就是函数`foo()`，所以输出就是`foo`

- 1. IIFE（自执行函数）

```js
var n = '林一一';
(function p(){
    console.log(n)
})()
/* 输出
*   林一一
/ 
复制代码
```

> 同样也是产生了闭包`p()`，存在 `window`下的引用 `n`。

- 1. 循环赋值

```js
for(var i = 0; i<10; i++){
  (function(j){
       setTimeout(function(){
        console.log(j)
    }, 1000) 
  })(i)
}
复制代码
```

> 因为存在闭包的原因上面能依次输出1~10，闭包形成了10个互不干扰的私有作用域。将外层的自执行函数去掉后就不存在外部作用域的引用了，输出的结果就是连续的 10。为什么会连续输出10，因为 JS 是单线程的遇到异步的代码不会先执行(会入栈)，等到同步的代码执行完 `i++` 到 10时，异步代码才开始执行此时的 `i=10` 输出的都是 10。

- 1. 使用回调函数就是在使用闭包

```js
window.name = '林一一'
setTimeout(function timeHandler(){
  console.log(window.name);
}, 100)
复制代码
```

### 使用闭包需要注意什么

> 容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。

### 经典面试题

- for 循环和闭包(号称必刷题)

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]()
/* 输出
    3
    3
    3
/
复制代码
```

> 这里的 `i` 是全局下的 `i`，共用一个作用域，当函数被执行的时候这时的 `i=3`，导致输出的结构都是3。

- 使用闭包改善上面的写法达到预期效果，写法1：自执行函数和闭包

```js
var data = [];

for (var i = 0; i < 3; i++) {
    (function(j){
      setTimeout( data[j] = function () {
        console.log(j);
      }, 0)
    })(i)
}

data[0]();
data[1]();
data[2]()
复制代码
```

- 写法2：使用 `let`

```js
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]()
复制代码
```

> `let` 具有块级作用域，形成的3个私有作用域都是互不干扰的。

## 9. 原型和原型链 

## 10. prototype与__proto__的关系与区别 

## 11. 继承的实现方式及比较 

## 12. 深拷贝与浅拷贝 

## 13. 防抖和节流 

## 14. 作用域和作用域链、执行期上下文 

## 15. DOM常见的操作方式 

## 16. Array.sort()方法与实现机制 

## 17. Ajax的请求过程 

## 18. JS的垃圾回收机制 

## 19. JS中的String、Array和Math方法 

## 20. addEventListener和onClick()的区别 

## 21. new和Object.create的区别 

## 22. DOM的location对象 

## 23. 浏览器从输入URL到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程） 

## 24. 跨域、同源策略及跨域实现方式和原理 

## 25. 浏览器的回流（Reflow）和重绘（Repaints） 

## 26. [JavaScript]()中的arguments 

## 27. EventLoop事件循环 

## 28. 宏任务与微任务 

## 29. BOM属性对象方法 

## 30. 函数柯里化及其通用封装 

## 31.js map和reduce方法

## 32.==和===的区别

## 33.settimeout作用于倒计时为什么有误差

#  二、ES6 

1. let、const和var的概念与区别 
2. 变量提升与暂时性死区 
3. 变量的结构赋值 
4. 箭头函数及其this问题 
5. Symbol概念及其作用 
6. Set和Map数据结构 
7. Proxy 
8. Reflect对象 
9. Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法） 
10. Iterator和for...of（Iterator遍历器的实现） 
11. 循环语法比较及使用场景（for、forEach、for...in、for...of） 
12. Generator及其异步方面的应用 
13. async函数 
14. 几种异步方式的比较（回调、setTimeout、Promise、Generator、async） 
15. class基本语法及继承 
16. 模块加载方案比较（CommonJS和ES6的Module） 
17. ES6模块加载与CommonJS加载的原理 

#  三、HTML/CSS 

1. CSS权重及其引入方式 
2. <a></a>标签全部作用 
3. 用CSS画三角形 
4. 未知宽高元素水平垂直居中（方案及比较） 
5. 元素种类的划分 
6. 盒子模型及其理解 
7. 定位方式及其区别（文档流） 
8. margin塌陷及合并问题 
9. 浮动模型及清除浮动的方法 
10. CSS定位属性 
11. display及相关属性 
12. IFC与BFC 
13. 圣杯布局和双飞翼布局的实现 
14. Flex布局 
15. px、em、rem的区别 
16. Less预处理语言 
17. 媒体查询 
18. vh与vw 
19. H5的语义化作用及语义化标签 
20. Web Worker和Web Socket 
21. CSS3及相关动画 
22. 如何实现响应式布局 
23. SEO的概念及实现 
24. HTML5的新特性 
25. Less和Sass使用 

#  四、HTTP与计算机网络 

### 1.TCP/IP协议分层管理 

### 2.三次握手四次挥手机制及原因 

### 3.HTTP方法 

### 4.GET和POST的区别 

### 5.HTTP建立持久连接的意义 

### 6.HTTP报文的结构 

### 7.HTTP状态码 

### 8.Web服务器及其组成 

### 9.HTTP报文首部 

### 10.HTTP通用首部字段 

### 11.HTTP请求首部字段、响应首部字段、实体首部字段 

### 12.Cookie相关首部字段 

### 13.HTTPS与HTTP区别及实现方式 

### 14.Cookie与Session 

### 15.基于HTTP的功能追加协议（SPY、WebSocket、HTTP） 

### 16.常见的Web攻击分类 

### 17.TCP与UDP区别 

### 18.存储机制localStorage、sessionStorage与Cookie存储技术 

### 19.XSS攻击及防御 

### 20.CSRF攻击及防御

### 21.从浏览器地址栏输入url到请求返回发生了什么

#### 1.首先会进行 url 解析，根据 dns 系统进行 ip 查找。**

##### 问dns解析流程，并且html如何做dns优化

首先dns这个属于很久以前在计算机网络谢希仁版看到过了，有一些细节忘了，但是大致流程是记得的。比如说查询一个网址为：[www.baidu.com](https://link.juejin.cn/?target=http%3A%2F%2Fwww.baidu.com)

0、先找浏览器缓存

1、器中输入[www.baidu.com](https://link.juejin.cn/?target=https%3A%2F%2Fwww.baidu.com) 域名，操作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回。//先找浏览器缓存

2、hosts文件没有就去查本地dns解析器有没有缓存。（这个我没答上来）

3、然后就去找我们计算机上配置的dns服务器上有或者有缓存，就返回

4、还没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址

注:后面查资料才发现dns查询有两种模式，一种是转发模式，一种是非转发模式，我上面说的4是非转发模式。

前端的dns优化，可以在html页面头部写入dns缓存地址，比如

```
<meta http-equiv="x-dns-prefetch-control" content="on" />
<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
复制代码
```

终于抗过了第一轮的猛问，接着我继续说从浏览器地址栏输入url到请求返回发生了什么

#### 2.

#  五、[前端]()工程化 

1. [前端]()工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、[项目]()监控）
2. Webpack基本概念与配置 
3. loader与plugin原理与实现 
4. Webpack的模块热替换及实现 
5. Webpack的优化问题 
6. SPA及其优缺点 
7. SSR实现及优缺点 
8. 设计模式（工厂模式、单例模式、原型模式、***模式、适配器模式、观察者模式等...） 

#  六、Vue



#  七、NodeJS 

1. NodeJS基本概念与特点 
2. CommonJS规范、核心模块 
3. Node的异步I/O 
4. Node的内存控制 
5. Node构建网络服务（TCP、HTTP、Web Socket服务等） 
6. Node的进程 

#  八、需要会手撕的代码部分 

1. Promise（A+规范）、then、all方法 
2. Iterator遍历器实现 
3. Thunk函数实现（结合Generator实现异步） 
4. async实现原理（spawn函数） 
5. class的继承 
6. 防抖和节流 
7. Ajax原生实现 
8. 深拷贝的几种方法与比较 
9. 继承的几种实现与比较 
10. 未知宽高的元素水平垂直居中 
11. 三栏布局的实现 
12. 两栏布局的实现 
13. React高阶组件 
14. 数组去重 
15. 几种[排序]()[算法]()的实现及其复杂度比较
16. 前序后序遍历[二叉树]()（非递归）
17. [二叉树]()深度遍历（分析时间复杂度）
18. 跨域的实现（JSONP、CORS） 

#  九、数据可视化 

1. Canvas和SVG的区别 
2. 在考虑设计可视化图表时，结合Canvas和SVG特性会怎么取舍 
3. 常见的可视化组件库 
4. 可视化组件库如Echarts的设计思路 
5. 一些偏向底层的可视化组件库和[前端]()框架结合方面需要考虑哪些问题
6. 可视化组件如何做到数据驱动？ 

#  十、计算机基础 

1. 计算机系统 
2. 线程与进程 
3. 常见的git指令 
4. Linux相关指令 
5. 其他类型的编程语言（如Java） 
6. 数据库